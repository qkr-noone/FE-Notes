## 我的面试总结
### 9.10面试经历
一面 40 min
1.	自我介绍
2.	为啥独立负责店铺装修
3.	H5 响应式适配方案有哪些
    * 百分比 (+ 媒体查询)
    * rem
    * vh/vw
    * rem + vw/vh
    * 媒体查询 （流式布局 + 弹性布局）
    https://www.jianshu.com/p/2c33921d5a68
4.	PC 适配方案有哪些
    * 媒体查询
    * flex 百分比
    * 栅格布局
5.	U3D 开发使用什么技术 JS 还是 C#
    * C#
6.	Bootstrap 适配是基于什么实现的
    * 媒体查询
7.	Vue React Angular 使用过嘛  说了 IM
8.	Vue 国际化用什么方案
    * vue-i18n
9.	皮肤切换有哪些方案
    * 使用全局的样式覆盖（前端通用）
    https://www.jianshu.com/p/35e0581629d2
    https://github.com/ALetterSong/Note/issues/15
    https://juejin.im/post/6844903812151377927
    https://juejin.im/post/6844904122643120141
    [使用 css/less 动态更换主题色（换肤功能）](https://www.cnblogs.com/leiting/p/11203383.html)
10.	Vue React 对比有哪些优缺点
    * 相似之处
    > * 使用 Virtual DOM
    > * 提供了响应式和组件化的视图组件
    > * 将注意力集中保持在核心库，将其它功能如路由和全局状态管理交给相关库
    * 优势
    > * 在 React 应用中，当某个组件的状态发生变化时，该组件会重新渲染整个组件子树。(使用 PureComponent，或是手动实现 shouldComponentUpdate 方法来优化, 且需要使用不可变的数据结构来使得组件更容易被优化)；在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，系统能精确知晓组件被重渲染，并且不需要重新渲染子树。
    > * 组件作用域内的 CSS  Vue 设置样式的默认方法是单文件组件里类似 style 的标签。最后，Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules —— 全部都在 \<style\> 标签内。
    > * Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，React 的生态系统相比 Vue 更加繁荣。
    > * Vue 提供了 CLI 脚手架，能让你通过交互式的脚手架引导非常容易地构建项目。
    > * 开发者可通过阅读指南就可以建立简单的应用程序。
    > * React Native 能使你用相同的组件模型编写有本地渲染能力的 APP (iOS 和 Android)。能同时跨多平台开发，对开发者是非常棒的。
    [对比其他框架](https://cn.vuejs.org/v2/guide/comparison.html#React)
    [Vue与React两个框架的粗略区别对比](https://juejin.im/post/6844903742530142221)
    [前端框架用vue还是react？清晰对比两者差异](https://juejin.im/post/6844903974437388295)
    [关于Vue和React的一些对比及个人思考（上）](https://juejin.im/post/6844904040564785159)
    [关于Vue和React的一些对比及个人思考（中）](https://juejin.im/post/6844904052812169229)
    [Vue3 究竟好在哪里？（和 React Hook 的详细对比）](https://juejin.im/post/6844904132109664264)
    [Vue 优缺点](http://static.kancloud.cn/lidongxu_heilong/ldx_ldx/1006971)
  * Vue2.0
    > 优点
    1. 易于使用： Vue.js包含基于HTML的标准模板，可以更轻松地使用和修改现有应用程序。
    2. 更顺畅的集成：无论是单页应用程序还是复杂的Web界面，Vue.js都可以更平滑地集成更小的部件，而不会对整个系统产生任何影响。
    3. 更好的性能，更小的尺寸：它占用更少的空间，并且往往比其他框架提供更好的性能。
    4. 精心编写的文档：通过详细的文档提供简单的学习曲线，无需额外的知识; HTML和JavaScript将完成工作。
    5. 适应性：整体声音设计和架构使其成为一种流行的JavaScript框架。它提供无障碍的迁移，简单有效的结构和可重用的模板。
    > 缺点：
    1. 功能的增长，复杂组件的代码变得越来越难以阅读和理解，在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项(options)组织代码，但是有的时候通过逻辑关系组织代码更有意义。
    2. 缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。
    3. 类型推导不够友好。(TypeScript)
    [更好的逻辑复用与代码组织、更好的类型推导](https://vue-composition-api-rfc.netlify.app/zh/#%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9B%AE%E7%9A%84)
11.	Vue 自定义指令生命周期有哪些 -> 钩子函数
    * bind、inserted、update、componentUpdated、unbind
    https://cn.vuejs.org/v2/guide/custom-directive.html#ad
12.	Vue 指令有哪些
    * v-text、v-html、v-model
    * v-if、v-else、v-else-if、v-show
    * v-for、v-on、v-bind、v-once
    * v-slot、v-pre、v-cloak
13.	Vuex 不用 getters 可以获取到里面的数据嘛
    * store.state.modules.val
    * mapState 辅助函数
14.	为什么要用 getter
    * store 中的 state 中派生出一些状态，计算属性 -- 加工、过滤 state中的数据。
    * Vuex 允许我们在 store 中定义 "getter"（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
    * 通过方法访问你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。
    * mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
    https://vuex.vuejs.org/zh/guide/getters.html
15.	Vuex 为什么要分 Module
    * 所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。
    * 
    https://vuex.vuejs.org/zh/guide/modules.html
16.	Vuex 优缺点
    * 缺点:
    > * 页面刷新state会初始化状态，状态不能持久化
    > * 小型和简单的项目，没有必要使用，会繁琐冗余
    * 优点:
    > * 解决了非父子组件的消息传递（将数据存放在state中）
    > * 以一个全局单例模式管理组件的共享状态，代码结构化且易维护
17.	Vue 的原型链一般拿来做什么
    * 使用到的数据/实用工具，但是不想污染全局作用域。可以通过在实例原型上添加属性，可以在每个 Vue 的实例中使用
    > * Vue.prototype.$axios = axios - 全局注册，使用方法为:this.$axios
    > * Vue.prototype.$qs = qs - 全局注册，使用方法为:this.$qs
18.	如何优化 Webpack 编译速度 打包速度 打包大小
19.	打包生成 20M 带宽 20M 高并发1万个访问网站会怎么 前端解决方法
20.	ES6 操作数组方法有哪些
    * ES6
    > * 扩展运算符(...) 转换数组为用逗号分隔的参数序列 [...arr]
    > * Array.of()、Array.from()
    > * findIndex()、find()、fill()、copyWithin()
    > * keys()、values()、entries() 返回以索引值、属性值、索引值和属性值为遍历器的对象 即 Array Iterator {}
    * ES2016
    > * includes()
    * ES2019
    > * flat()：扁平化数组，返回新数组
    > * flatMap()：映射且扁平化数组，返回新数组(只能展开一层数组)
21.	上传文件有哪几种方法
    * form 表单上传 enctype="multipart/form-data"，表明表单需要上传二进制数据。
    * formData Ajax 上传
    * fileReader 读取文件数据进行上传 图片预览
      ```js
        var fr = new FileReader();
        fr.readAsDataURL(file);
        fr.onload = function (event) {
          var data= event.target.result; // 此处获得的data是base64格式的数据
          img.src = data;
          ajax(url, {data}, function(){})
        }
        // other
        var img = document.createElement("img");
        img.src = window.URL.createObjectURL(file);
        img.onload = function() {
          // 明确地通过调用释放
          window.URL.revokeObjectURL(this.src);
        }
        previewArea.appendChild(img);
      ```
    * 拖拽上传
      利用HTML5的drag & drop事件，我们可以很快实现对拖拽的支持。首先我们可能需要确定一个允许拖放的区域，然后绑定相应的事件进行处理。
      ```js
        dropArea.addEventListener("drop", handleDrop, false);
        function handleDrop(e) {
          e.stopPropagation();
          e.preventDefault();
          var files = e.dataTransfer.files;
          // handle files ...
        }
      ```
      https://juejin.im/entry/6844903476804190221
      https://www.jianshu.com/p/7636d5c60a8d
22.	跨域有几种方法
    @import "../../Classic JS/Cross-domain-more.js"
    >> {code_block=true class="line-numbers" as="vega-lite" line_begin=1 line_end=233}
23.	了解哪些最近新技术
    * [Vue3.0](https://github.com/vuejs/vue-next)
    * [TypeScript4.0](https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/)
      [精读《Typescript 4》](https://zhuanlan.zhihu.com/p/159039209)
24.	TS 有用过吧
25.	TS 有什么优缺点
    * 使用TS的好处：
      > * （1）增强代码的可读性和可维护性，强类型的系统相当于最好的文档，在编译时即可发现大部分的错误，增强编辑器的功能。
      > * （2）包容性，js文件可以直接改成 ts 文件，不定义类型可自动推论类型，可以定义几乎一切类型，ts 编译报错时也可以生成 js 文件，兼容第三方库，即使不是用ts编写的
      > * （3）有活跃的社区，大多数的第三方库都可提供给 ts 的类型定义文件，完全支持 es6 规范
    * 使用 TS 的缺点：
      > * （1）增加学习成本，需要理解接口（Interfaces）和泛型（Generics），类（class），枚举类型（Enums）
      > * （2）短期增加开发成本，增加类型定义，但减少维护成本
      > * （3）ts 集成到构建流程需要一定的工作量
      > * （4）和有些库结合时不是很完美
26.	Vue3.0 劣势和缺点 没有用过嘛
    1. Proxy 取代 Object.defineProperty 的优缺点
    > 1. 可以劫持整个对象，并返回一个新对象
    > 2. Proxy 可以直接监听数组的变化
    > 3. 有13中劫持对象的操作方法
    > * 不能深度劫持对象属性 (缺点)
    > * 可能会触发多次的数据劫持调用 (缺点)
    2. TypeScript: 更优秀的 TS 支持，可以享受到自动的类型定义提示
    3. Composition API: [组合API](https://composition-api.vuejs.org/zh/api.html)
    4. Performance
    > * 重写虚拟DOM
    > * 编译模板的优化 (模板编译的静态标记)
    > * 事件缓存 (cacheHandlers)
    > * 静态提升
    5. Tree shaking support: 可以将无用模块'剪辑'，仅打包需要的。
    6. Custom Renderer API: 自定义渲染器 API
      https://zhuanlan.zhihu.com/p/134302690
      https://juejin.im/post/6844904134647234568
27.	解释下笔试最后一题的答案
28.	上一家开发团队有多少人
29.	前端职业规划 自己在那个层级 如何达成你的目标

二面 23 min
1.	自我介绍
2.	公司做什么业务的
3.	前端的 3D 展示
4.	3D 和前端交互调试？ 通过 iframe 放 3D？
    * 
5.	直播相关技术怎么实现的
6.	直播流 先推到流服务器 这个服务器部署在哪里
7.	Chrome 年底不支持 iframe 你们有什么方案嘛
8.	有浏览器兼容的需要嘛 用哪些
9.	H5 怎么考虑对不同屏幕的适配呢
10.	rem 一个单位代表什么含义
11.	你进入到项目是 项目处于一个什么阶段
12.	项目什么时候上线
13.	EDI 需要做什么调整
14.	优化里面有答案 CDN 优化 它有什么好处
15.	页面加载引起页面卡顿 你是怎么处理的
16.	单页面首屏加载有哪些优化手段 项目图片怎么压缩
17.	前后端分离 进度不一致 你一般有哪些办法怎么来做的 怎么办
18.	基于什么考虑想换一份工作
19.	有接触过音乐播放这一块嘛
20.	哪些途径了解前端新技术发展动态

```js
  // https://github.com/woai3c/Front-end-articles/blob/master/promise.md
  class Promise {
    constructor(executor) {
      this.onFulfilleds = []
      this.onRejecteds = []
      this.state = 'pending'

      const self = this

      function resolve(value) {
        if(self.state === 'pending') {
          self.state = 'fulfilled'
          self.value = value
          self.onFulfilleds.forEach(callback => callback())
        }
      }

      function reject(reason) {
        if(self.state === 'pending') {
          self.state = 'rejected'
          self.reason = reason
          self.onRejecteds.forEach(callback => callback())
        }
      }

      try {
        executor()
      } catch (error) {
        reject(error)
      }
    }

    then(onFulfilled, onRejected) {
      onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
      onRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason}

      const self = this
      const promise2 = new Promise((resolve, reject) => {
        self.onFulfilleds.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(self.value)
              if (x instanceof Promise) {
                x.then(val => resolve(val))
              } else {
                resolve(x)
              }
            } catch (error) {
              reject(error)
            }
          })
        })

        self.onRejecteds.push(() => {
          setTimeout(() => {
            tyr {
              if (x instanceof Promise) {
                const x = onRejected(self.reason)
                x.then(val => resolve(val))
              } else {
                resolve(x)
              }
            } catch(error) {
              reject(error)
            }
          })
        })
      })
      return promise2
    }
  }
```