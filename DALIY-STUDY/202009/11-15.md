## 我的面试总结
### 9.10面试经历
一面 40 min
1.	自我介绍
2.	为啥独立负责店铺装修
3.	H5 响应式适配方案有哪些
    * 百分比 (+ 媒体查询)
    * rem
    * vh/vw
    * rem + vw/vh
    * 媒体查询 （流式布局 + 弹性布局）
    https://www.jianshu.com/p/2c33921d5a68
4.	PC 适配方案有哪些
    * 媒体查询
    * flex 百分比
    * 栅格布局
5.	U3D 开发使用什么技术 JS 还是 C#
    * C#
6.	Bootstrap 适配是基于什么实现的
    * 媒体查询
7.	Vue React Angular 使用过嘛  说了 IM
8.	Vue 国际化用什么方案
    * vue-i18n
9.	皮肤切换有哪些方案
    * 使用全局的样式覆盖（前端通用）
    https://www.jianshu.com/p/35e0581629d2
    https://github.com/ALetterSong/Note/issues/15
    https://juejin.im/post/6844903812151377927
    https://juejin.im/post/6844904122643120141
    [使用 css/less 动态更换主题色（换肤功能）](https://www.cnblogs.com/leiting/p/11203383.html)
10.	Vue React 对比有哪些优缺点
    * 相似之处
    > * 使用 Virtual DOM
    > * 提供了响应式和组件化的视图组件
    > * 将注意力集中保持在核心库，将其它功能如路由和全局状态管理交给相关库
    * 优势
    > * 在 React 应用中，当某个组件的状态发生变化时，该组件会重新渲染整个组件子树。(使用 PureComponent，或是手动实现 shouldComponentUpdate 方法来优化, 且需要使用不可变的数据结构来使得组件更容易被优化)；在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，系统能精确知晓组件被重渲染，并且不需要重新渲染子树。
    > * 组件作用域内的 CSS  Vue 设置样式的默认方法是单文件组件里类似 style 的标签。最后，Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules —— 全部都在 \<style\> 标签内。
    > * Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，React 的生态系统相比 Vue 更加繁荣。
    > * Vue 提供了 CLI 脚手架，能让你通过交互式的脚手架引导非常容易地构建项目。
    > * 开发者可通过阅读指南就可以建立简单的应用程序。
    > * React Native 能使你用相同的组件模型编写有本地渲染能力的 APP (iOS 和 Android)。能同时跨多平台开发，对开发者是非常棒的。
    [对比其他框架](https://cn.vuejs.org/v2/guide/comparison.html#React)
    [Vue与React两个框架的粗略区别对比](https://juejin.im/post/6844903742530142221)
    [前端框架用vue还是react？清晰对比两者差异](https://juejin.im/post/6844903974437388295)
    [关于Vue和React的一些对比及个人思考（上）](https://juejin.im/post/6844904040564785159)
    [关于Vue和React的一些对比及个人思考（中）](https://juejin.im/post/6844904052812169229)
    [Vue3 究竟好在哪里？（和 React Hook 的详细对比）](https://juejin.im/post/6844904132109664264)
11.	Vue 自定义指令生命周期有哪些 -> 钩子函数
    * bind、inserted、update、componentUpdated、unbind
    https://cn.vuejs.org/v2/guide/custom-directive.html#ad
12.	Vue 指令有哪些
    * v-text、v-html、v-model
    * v-if、v-else、v-else-if、v-show
    * v-for、v-on、v-bind、v-once
    * v-slot、v-pre、v-cloak
13.	Vuex 不用 getters 可以获取到里面的数据嘛
    * store.state.modules.val
    * mapState 辅助函数
14.	为什么要用 getter
    * store 中的 state 中派生出一些状态，计算属性 -- 加工、过滤 state中的数据。
    * Vuex 允许我们在 store 中定义 "getter"（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
    * 通过方法访问你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。
    * mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
    https://vuex.vuejs.org/zh/guide/getters.html
15.	Vuex 为什么要分 Module
    * 所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。
    * 
    https://vuex.vuejs.org/zh/guide/modules.html
16.	Vuex 优缺点
    * 缺点:
    > * 页面刷新state会初始化状态，状态不能持久化
    > * 小型和简单的项目，没有必要使用，会繁琐冗余
    * 优点:
    > * 解决了非父子组件的消息传递（将数据存放在state中）
    > * 以一个全局单例模式管理组件的共享状态，代码结构化且易维护
17.	Vue 的原型链一般拿来做什么
    * 使用到的数据/实用工具，但是不想污染全局作用域。可以通过在实例原型上添加属性，可以在每个 Vue 的实例中使用
    > * Vue.prototype.$axios = axios - 全局注册，使用方法为:this.$axios
    > * Vue.prototype.$qs = qs - 全局注册，使用方法为:this.$qs
18.	如何优化 Webpack 编译速度 打包速度 打包大小
19.	打包生成 20M 带宽 20M 高并发1万个访问网站会怎么 前端解决方法
20.	ES6 操作数组方法有哪些
    * ES6
    > * 扩展运算符(...) 转换数组为用逗号分隔的参数序列 [...arr]
    > * Array.of()、Array.from()
    > * findIndex()、find()、fill()、copyWithin()
    > * keys()、values()、entries() 返回以索引值、属性值、索引值和属性值为遍历器的对象 即 Array Iterator {}
    * ES2016
    > * includes()
    * ES2019
    > * flat()：扁平化数组，返回新数组
    > * flatMap()：映射且扁平化数组，返回新数组(只能展开一层数组)
21.	上传文件有哪几种方法
    * form 表单上传 enctype="multipart/form-data"，表明表单需要上传二进制数据。
    * formData Ajax 上传
    * fileReader 读取文件数据进行上传 图片预览
      ```js
        var fr = new FileReader();
        fr.readAsDataURL(file);
        fr.onload = function (event) {
          var data= event.target.result; // 此处获得的data是base64格式的数据
          img.src = data;
          ajax(url, {data}, function(){})
        }
        // other
        var img = document.createElement("img");
        img.src = window.URL.createObjectURL(file);
        img.onload = function() {
          // 明确地通过调用释放
          window.URL.revokeObjectURL(this.src);
        }
        previewArea.appendChild(img);
      ```
    * 拖拽上传
      利用HTML5的drag & drop事件，我们可以很快实现对拖拽的支持。首先我们可能需要确定一个允许拖放的区域，然后绑定相应的事件进行处理。
      ```js
        dropArea.addEventListener("drop", handleDrop, false);
        function handleDrop(e) {
          e.stopPropagation();
          e.preventDefault();
          var files = e.dataTransfer.files;
          // handle files ...
        }
      ```
      https://juejin.im/entry/6844903476804190221
      https://www.jianshu.com/p/7636d5c60a8d
22.	跨域有几种方法
    @import "../../Classic JS/Cross-domain-more.js"
    >> {code_block=true class="line-numbers" as="vega-lite" line_begin=1 line_end=233}
23.	了解哪些最近新技术
    * [Vue3.0](https://github.com/vuejs/vue-next)
    * [TypeScript4.0](https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/)
      [精读《Typescript 4》](https://zhuanlan.zhihu.com/p/159039209)
24.	TS 有用过吧
25.	TS 有什么优缺点
    * TS代码更易于理解，实现更快，产生的错误更少
26.	Vue3.0 劣势和缺点 没有用过嘛
27.	解释下笔试最后一题的答案
28.	上一家开发团队有多少人
29.	前端职业规划 自己在那个层级 如何达成你的目标

二面 23 min
1.	自我介绍
2.	公司做什么业务的
3.	前端的 3D 展示
4.	3D 和前端交互调试？ 通过 iframe 放 3D？
5.	直播相关技术怎么实现的
6.	直播流 先推到流服务器 这个服务器部署在哪里
7.	Chrome 年底不支持 iframe 你们有什么方案嘛
8.	有浏览器兼容的需要嘛 用哪些
9.	H5 怎么考虑对不同屏幕的适配呢
10.	rem 一个单位代表什么含义
11.	你进入到项目是 项目处于一个什么阶段
12.	项目什么时候上线
13.	EDI 需要做什么调整
14.	优化里面有答案 CDN 优化 它有什么好处
15.	页面加载引起页面卡顿 你是怎么处理的
16.	单页面首屏加载有哪些优化手段 项目图片怎么压缩
17.	前后端分离 进度不一致 你一般有哪些办法怎么来做的 怎么办
18.	基于什么考虑想换一份工作
19.	有接触过音乐播放这一块嘛
20.	哪些途径了解前端新技术发展动态

```js
  // https://github.com/woai3c/Front-end-articles/blob/master/promise.md
  class Promise {
    constructor(executor) {
      this.onFulfilleds = []
      this.onRejecteds = []
      this.state = 'pending'

      const self = this

      function resolve(value) {
        if(self.state === 'pending') {
          self.state = 'fulfilled'
          self.value = value
          self.onFulfilleds.forEach(callback => callback())
        }
      }

      function reject(reason) {
        if(self.state === 'pending') {
          self.state = 'rejected'
          self.reason = reason
          self.onRejecteds.forEach(callback => callback())
        }
      }

      try {
        executor()
      } catch (error) {
        reject(error)
      }
    }

    then(onFulfilled, onRejected) {
      onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
      onRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason}

      const self = this
      const promise2 = new Promise((resolve, reject) => {
        self.onFulfilleds.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(self.value)
              if (x instanceof Promise) {
                x.then(val => resolve(val))
              } else {
                resolve(x)
              }
            } catch (error) {
              reject(error)
            }
          })
        })

        self.onRejecteds.push(() => {
          setTimeout(() => {
            tyr {
              if (x instanceof Promise) {
                const x = onRejected(self.reason)
                x.then(val => resolve(val))
              } else {
                resolve(x)
              }
            } catch(error) {
              reject(error)
            }
          })
        })
      })
      return promise2
    }
  }
```