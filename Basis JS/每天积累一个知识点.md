#### 1. Vue 中组件的 name 的作用 
  a. 当项目使用keep-alive时，可搭配组件name进行缓存过滤 exclude="name"

  b. 递归组件 调用自身name 

  c. vue-devtools调试工具里显示的组见名称是由vue中组件name决定的

#### 2. Vue 中 provide 和 inject 及 Vue 中8种组件通信方式

  [vue中8种组件通信方式](https://juejin.im/post/5d267dcdf265da1b957081a3)

#### 3. 类数组 (不可使用数组方法)

  分类：

1. 用getElementsByTagName/Dom.children/ClassName() 获得的HTMLCollection

2. 用querySelector获得的nodeList

 转为数组的方法：

``
    function sumg (tem) {
      let args = 方法
      console.log(args.reduce((sum, cur) => sum + cur))
    }
    sum(1, 12)
    1. Array.from()  经常使用  => Array.from(arguments)
    2. Array.prototype.slice.call()   =>  Array.prototype.slice.call(arguments)
    3. ES6 展开运算符  => [... arguments]
    4. 利用 concat + apply   => Array.prototype.concat.apply([], arguments)
``
#### 4. JS 中判断数组是否包含某个值

  1. array.indexOf()  存在则返回下标  反之返回 -1

  2. array.includes() 存在则返回 true   反之 false

  3. array.find()  返回满足条件的第一个元素的值  没有则 返回 undefined

  4. array.findIndex() 返回满足条件的第一个元素的下标  没有则 返回 -1

  5. for 循环

#### 5. JS 中 flat --- 数组扁平化

  多维数组 ==> 一维数组

  let ary = [1, 2, [3, 3, 4, [5, 6], 6], 4]

  let str = JSON.stringify(ary)

```
  1. 调用 ES6 的 flat 方法
      ary = ary.flat(Infinity)
  
  2. replace  + split
      ary = str.replace(/(\[|\])/g, '').split(',')
  
  3. replace + JSON.parse
      str = str.replace(/(\[|\])/g, '')
      str = '[' + str + ']'
      ary = JSON.parse(str)
  
  4. 普通递归
      let result = []
      let fn = function (ary) {
        for (let i = 0; i < ary.length; i++) {
          let item = ary[i]
          if (Array.isArray(ary[i])) {
            fn(item)
          } else {
            result.push(item)
          }
        }
      }
  
  5. 利用 reduce 函数迭代
      function flatten (ary) {
        return ary.reduce((pre, cur) => {
          return pre.concat(Array.isArray(cur) ? flatten(cur) : cur)
        }, [])
      }
      let ary = [1, 2, 3, 4, [4, 5,6], [5,7, [8,9], 0], 9]
      console.log(flatten(ary))
  
  6. 扩展运算符
      while (ary.some(Array.isArray)) {
        ary = [].concat(...ary)
      }
```
#### 6. 函数防抖 和 节流

```
    防抖：
      function debounce(fn, delay) {
        let timer = null;
        return function () {
          if (timer) clearTimeout(timer);
          timer = setTimeout(() => {
            fn.apply(this, arguments);
          }, delay);
        }
      }

    节流：
      function throttle(fn, cycle) {
        let start = Date.now();
        let now;
        let timer;
        return function () {
          now = Date.now();
          clearTimeout(timer);
          if (now - start >= cycle) {
            fn.apply(this, arguments);
            start = now;
          } else {
            timer = setTimeout(() => {
              fn.apply(this, arguments);
            }, cycle);
          }
        }
      }
```

#### 7. axios 拦截器怎么配

```
    // 添加请求拦截器
    axios.interceptors.request.use(request => {
      // 在发送请求之前做些什么
      return request
    }, error => {
      return Promise.reject(error)
    })
    // 添加响应拦截器
    axios.interceptors.response.use(res => {
      // 对响应数据做点什么
      return res
    }, error => {
      return Promise.reject(error)
    })
```
